<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Runner – Arcade</title>
<style>
  :root{
    --bg:#fff; --fg:#000; --muted:#666;
  }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--fg);
    font-family:ui-monospace,Menlo,Consolas,monospace;
    display:grid;place-items:center;overflow:hidden;
  }
  #wrap{position:relative;}
  canvas{
    display:block;background:var(--bg);border:4px solid var(--fg);
    border-radius:16px;box-shadow:0 12px 30px rgba(0,0,0,0.08);
  }
  .hud{position:absolute;left:18px;top:16px;font-weight:700;font-size:14px;}
  .hint{position:absolute;right:18px;bottom:14px;font-size:13px;opacity:0.75;}
  .overlay{
    position:fixed;inset:0;display:grid;place-items:center;text-align:center;
    font-size:24px;color:var(--fg);pointer-events:none;z-index:3;
    opacity:0;transform:scale(0.95);transition:opacity .3s ease,transform .3s ease;
    background:rgba(255,255,255,0.95);
    backdrop-filter:blur(4px);
  }
  .overlay.show{opacity:1;transform:scale(1);}
  .overlay>div{animation:slideUp 0.5s ease;}
  @keyframes slideUp{from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}
  @media (max-width:600px){canvas{width:360px;height:600px}}
</style>
</head>
<body>
<div id="wrap">
  <div class="hud">Score: <span id="score">0</span> | Best: <span id="best">0</span></div>
  <div class="hint">Space or Click to jump • R restart</div>
  <canvas id="c" width="420" height="600"></canvas>
</div>
<div class="overlay show" id="overlay">
  <div>
    <div style="font-weight:700;font-size:26px">Pixel Runner</div>
    <div style="opacity:0.8;margin-top:10px;font-size:16px">Jump over obstacles and collect shields</div>
    <div style="opacity:0.7;margin-top:12px;font-size:14px">Press Space to start</div>
  </div>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const overlay = document.getElementById('overlay');

const GROUND_Y = H - 60;
const PLAYER_SIZE = 24;
const GRAVITY = 0.5;
const JUMP_POWER = -10;

// Pastel colors for obstacles
const COLORS = ['#FFB6C1', '#E6E6FA', '#98FB98', '#F0E68C', '#FFA07A', '#87CEEB', '#DDA0DD', '#F5DEB3'];

// Enhanced Audio System
const ac = new (window.AudioContext||window.webkitAudioContext)();

function createEnvelope(gain, attack, decay, sustain, release, duration) {
  const now = ac.currentTime;
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.exponentialRampToValueAtTime(1, now + attack);
  gain.gain.exponentialRampToValueAtTime(sustain, now + attack + decay);
  gain.gain.setValueAtTime(sustain, now + duration - release);
  gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
}

const sounds = {
  jump() {
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(380, ac.currentTime);
    osc.frequency.exponentialRampToValueAtTime(520, ac.currentTime + 0.1);
    
    gain.gain.setValueAtTime(0.15, ac.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.12);
    
    osc.connect(gain).connect(ac.destination);
    osc.start();
    osc.stop(ac.currentTime + 0.15);
  },
  
  land() {
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, ac.currentTime);
    osc.frequency.exponentialRampToValueAtTime(80, ac.currentTime + 0.08);
    
    gain.gain.setValueAtTime(0.12, ac.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.1);
    
    osc.connect(gain).connect(ac.destination);
    osc.start();
    osc.stop(ac.currentTime + 0.12);
  },
  
  score() {
    const osc1 = ac.createOscillator();
    const osc2 = ac.createOscillator();
    const gain = ac.createGain();
    
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.frequency.value = 800;
    osc2.frequency.value = 1200;
    
    gain.gain.setValueAtTime(0.08, ac.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.15);
    
    osc1.connect(gain).connect(ac.destination);
    osc2.connect(gain);
    osc1.start();
    osc2.start();
    osc1.stop(ac.currentTime + 0.18);
    osc2.stop(ac.currentTime + 0.18);
  },
  
  highScore() {
    const times = [0, 0.08, 0.16];
    const freqs = [800, 1000, 1400];
    
    times.forEach((time, i) => {
      setTimeout(() => {
        const osc = ac.createOscillator();
        const gain = ac.createGain();
        
        osc.type = 'triangle';
        osc.frequency.value = freqs[i];
        
        gain.gain.setValueAtTime(0.1, ac.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.12);
        
        osc.connect(gain).connect(ac.destination);
        osc.start();
        osc.stop(ac.currentTime + 0.15);
      }, time * 1000);
    });
  },
  
  shield() {
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, ac.currentTime);
    osc.frequency.exponentialRampToValueAtTime(1200, ac.currentTime + 0.2);
    
    gain.gain.setValueAtTime(0.12, ac.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.25);
    
    osc.connect(gain).connect(ac.destination);
    osc.start();
    osc.stop(ac.currentTime + 0.3);
  },
  
  shieldHit() {
    const osc = ac.createOscillator();
    const gain = ac.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(400, ac.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, ac.currentTime + 0.15);
    
    gain.gain.setValueAtTime(0.15, ac.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.18);
    
    osc.connect(gain).connect(ac.destination);
    osc.start();
    osc.stop(ac.currentTime + 0.2);
  },
  
  death() {
    // Main death sound - descending
    const osc1 = ac.createOscillator();
    const gain1 = ac.createGain();
    
    osc1.type = 'sawtooth';
    osc1.frequency.setValueAtTime(300, ac.currentTime);
    osc1.frequency.exponentialRampToValueAtTime(80, ac.currentTime + 0.5);
    
    gain1.gain.setValueAtTime(0.2, ac.currentTime);
    gain1.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.5);
    
    osc1.connect(gain1).connect(ac.destination);
    osc1.start();
    osc1.stop(ac.currentTime + 0.6);
    
    // Impact sound
    const osc2 = ac.createOscillator();
    const gain2 = ac.createGain();
    
    osc2.type = 'square';
    osc2.frequency.value = 60;
    
    gain2.gain.setValueAtTime(0.25, ac.currentTime);
    gain2.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.15);
    
    osc2.connect(gain2).connect(ac.destination);
    osc2.start();
    osc2.stop(ac.currentTime + 0.2);
  }
};

let state = {
  player: {
    x: 80,
    y: GROUND_Y - PLAYER_SIZE,
    vy: 0,
    grounded: true,
    squash: 1,
    rotation: 0,
    trail: [],
    runCycle: 0,
    landSquashTimer: 0
  },
  obstacles: [],
  powerups: [],
  particles: [],
  score: 0,
  best: +localStorage.getItem('pixel_runner_best') || 0,
  running: false,
  gameOver: false,
  firstStart: true,
  speed: 3.5,
  spawnTimer: 0,
  shield: false,
  shieldTimer: 0,
  comboCount: 0
};

bestEl.textContent = state.best;

// Input
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if(e.code === 'Space'){
    if(state.firstStart && !state.running){
      start();
    } else if(state.gameOver){
      reset();
    } else {
      jump();
    }
  }
  if(e.key === 'r' || e.key === 'R'){
    if(state.gameOver) reset();
  }
});
window.addEventListener('keyup', e => keys[e.key] = false);
canvas.addEventListener('click', () => {
  if(state.firstStart && !state.running){
    start();
  } else if(state.gameOver){
    reset();
  } else {
    jump();
  }
});

function start(){
  state.running = true;
  state.firstStart = false;
  overlay.classList.remove('show');
}

function reset(){
  state.player.y = GROUND_Y - PLAYER_SIZE;
  state.player.vy = 0;
  state.player.grounded = true;
  state.player.squash = 1;
  state.player.rotation = 0;
  state.player.trail = [];
  state.player.runCycle = 0;
  state.player.landSquashTimer = 0;
  state.obstacles = [];
  state.powerups = [];
  state.particles = [];
  state.score = 0;
  state.running = false;
  state.gameOver = false;
  state.speed = 3.5;
  state.spawnTimer = 0;
  state.shield = false;
  state.shieldTimer = 0;
  state.comboCount = 0;
  scoreEl.textContent = '0';
  start();
}

function jump(){
  if(!state.running || state.gameOver) return;
  if(state.player.grounded){
    state.player.vy = JUMP_POWER;
    state.player.grounded = false;
    state.player.squash = 0.7;
    sounds.jump();
    
    // Jump particles
    for(let i = 0; i < 8; i++){
      state.particles.push({
        x: state.player.x + PLAYER_SIZE/2,
        y: state.player.y + PLAYER_SIZE,
        vx: (Math.random() - 0.5) * 3,
        vy: Math.random() * 2 + 1,
        life: 1,
        size: 2 + Math.random() * 2,
        color: '#666'
      });
    }
  }
}

function spawnObstacle(){
  const w = 20 + Math.random() * 25;
  const h = 20 + Math.random() * 30;
  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  
  state.obstacles.push({
    x: W + w,
    y: GROUND_Y - h,
    w, h, color
  });
}

function spawnPowerup(){
  // Very rare: 0.001 instead of 0.002
  if(Math.random() < 0.001){
    const size = 18;
    state.powerups.push({
      x: W + 20,
      y: GROUND_Y - 80 - Math.random() * 40,
      size,
      pulse: 0,
      sparkles: []
    });
  }
}

function spawnParticles(x, y, color, count = 15){
  for(let i = 0; i < count; i++){
    state.particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8,
      life: 1,
      size: 2 + Math.random() * 4,
      color: color
    });
  }
}

function update(dt){
  if(state.gameOver){
    state.particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.15;
      p.life -= 0.015;
    });
    state.particles = state.particles.filter(p => p.life > 0);
    return;
  }

  if(!state.running) return;

  const p = state.player;
  
  // Running animation
  if(p.grounded){
    p.runCycle += state.speed * 0.15;
    p.squash = 1 + Math.sin(p.runCycle) * 0.08;
  }
  
  // Physics
  p.vy += GRAVITY;
  p.y += p.vy;
  
  if(p.y >= GROUND_Y - PLAYER_SIZE){
    if(!p.grounded){
      sounds.land();
      p.landSquashTimer = 8;
    }
    p.y = GROUND_Y - PLAYER_SIZE;
    p.vy = 0;
    p.grounded = true;
    p.rotation = 0;
  } else {
    p.rotation += 0.12;
  }
  
  // Land squash effect
  if(p.landSquashTimer > 0){
    p.landSquashTimer--;
    p.squash = 1.3 - (p.landSquashTimer / 8) * 0.3;
  }
  
  // Squash recovery
  if(p.landSquashTimer === 0){
    p.squash += (1 - p.squash) * 0.2;
  }
  
  // Trail
  if(p.grounded && Math.random() < 0.3){
    p.trail.push({
      x: p.x + PLAYER_SIZE/2,
      y: p.y + PLAYER_SIZE,
      life: 1,
      size: 4
    });
  }
  if(p.trail.length > 10) p.trail.shift();
  p.trail.forEach(t => t.life -= 0.08);
  p.trail = p.trail.filter(t => t.life > 0);
  
  // Shield timer
  if(state.shieldTimer > 0){
    state.shieldTimer -= dt;
    if(state.shieldTimer <= 0) state.shield = false;
  }
  
  // Speed up over time
  state.speed += 0.0008;
  
  // Spawn obstacles
  state.spawnTimer += dt;
  const spawnDelay = Math.max(800, 1400 - state.score * 2);
  if(state.spawnTimer >= spawnDelay){
    state.spawnTimer = 0;
    spawnObstacle();
  }
  
  spawnPowerup();
  
  // Update obstacles
  state.obstacles.forEach((obs, idx) => {
    obs.x -= state.speed;
    
    // Collision
    if(p.x < obs.x + obs.w &&
       p.x + PLAYER_SIZE > obs.x &&
       p.y < obs.y + obs.h &&
       p.y + PLAYER_SIZE > obs.y){
      if(!state.shield){
        endGame();
        return;
      } else {
        // Destroy obstacle with shield - remove shield after one hit
        state.obstacles.splice(idx, 1);
        spawnParticles(obs.x + obs.w/2, obs.y + obs.h/2, obs.color, 20);
        sounds.shieldHit();
        state.score += 5;
        state.comboCount++;
        // Remove shield after hitting obstacle
        state.shield = false;
        state.shieldTimer = 0;
      }
    }
    
    // Score when passing
    if(obs.x + obs.w < p.x && !obs.scored){
      obs.scored = true;
      state.score++;
      scoreEl.textContent = state.score;
      sounds.score();
      
      if(state.score > state.best){
        state.best = state.score;
        bestEl.textContent = state.best;
        localStorage.setItem('pixel_runner_best', state.best);
        sounds.highScore();
      }
    }
  });
  
  state.obstacles = state.obstacles.filter(o => o.x + o.w > -40);
  
  // Update powerups
  state.powerups.forEach((pow, idx) => {
    pow.x -= state.speed;
    pow.pulse += 0.1;
    
    // Sparkles
    if(Math.random() < 0.15){
      pow.sparkles.push({
        x: pow.x + pow.size/2 + (Math.random() - 0.5) * pow.size,
        y: pow.y + pow.size/2 + (Math.random() - 0.5) * pow.size,
        life: 1,
        size: 2 + Math.random() * 2
      });
    }
    pow.sparkles.forEach(s => s.life -= 0.05);
    pow.sparkles = pow.sparkles.filter(s => s.life > 0);
    
    // Collision
    if(p.x < pow.x + pow.size &&
       p.x + PLAYER_SIZE > pow.x &&
       p.y < pow.y + pow.size &&
       p.y + PLAYER_SIZE > pow.y){
      state.shield = true;
      state.shieldTimer = 5000;
      state.powerups.splice(idx, 1);
      spawnParticles(pow.x + pow.size/2, pow.y + pow.size/2, '#66f', 25);
      sounds.shield();
    }
  });
  
  state.powerups = state.powerups.filter(o => o.x > -40);
  
  // Update particles
  state.particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life -= 0.018;
    p.vx *= 0.99;
  });
  state.particles = state.particles.filter(p => p.life > 0);
}

function draw(){
  ctx.save();
  
  ctx.clearRect(0, 0, W, H);
  
  // Ground
  ctx.fillStyle = '#000';
  ctx.fillRect(0, GROUND_Y, W, 4);
  
  // Ground decoration
  for(let i = 0; i < W; i += 30){
    ctx.fillStyle = '#ddd';
    ctx.fillRect(i, GROUND_Y + 4, 15, 2);
  }
  
  // Particles
  state.particles.forEach(p => {
    ctx.globalAlpha = Math.max(0, p.life * 0.8);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;
  
  // Trail
  state.player.trail.forEach(t => {
    ctx.globalAlpha = t.life * 0.4;
    ctx.fillStyle = '#000';
    const size = t.size * t.life;
    ctx.fillRect(t.x - size/2, t.y - size/2, size, size);
  });
  ctx.globalAlpha = 1;
  
  // Obstacles - simple, no animations
  state.obstacles.forEach(obs => {
    ctx.fillStyle = obs.color;
    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
    
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
  });
  
  // Powerups
  state.powerups.forEach(pow => {
    const pulseScale = 1 + Math.sin(pow.pulse) * 0.15;
    
    // Sparkles
    pow.sparkles.forEach(s => {
      ctx.globalAlpha = s.life;
      ctx.fillStyle = '#fff';
      ctx.fillRect(s.x - s.size/2, s.y - s.size/2, s.size, s.size);
    });
    ctx.globalAlpha = 1;
    
    // Shield icon
    ctx.save();
    ctx.translate(pow.x + pow.size/2, pow.y + pow.size/2);
    ctx.scale(pulseScale, pulseScale);
    
    ctx.fillStyle = '#66f';
    ctx.beginPath();
    ctx.moveTo(0, -pow.size/2);
    ctx.lineTo(pow.size/2.5, -pow.size/4);
    ctx.lineTo(pow.size/3, pow.size/2.5);
    ctx.lineTo(0, pow.size/2);
    ctx.lineTo(-pow.size/3, pow.size/2.5);
    ctx.lineTo(-pow.size/2.5, -pow.size/4);
    ctx.closePath();
    ctx.fill();
    
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  });
  
  // Player
  const p = state.player;
  ctx.save();
  ctx.translate(p.x + PLAYER_SIZE/2, p.y + PLAYER_SIZE/2);
  
  if(!p.grounded){
    ctx.rotate(p.rotation);
  }
  
  ctx.scale(1, p.squash);
  
  // Shield effect - minimal and professional
  if(state.shield){
    const shieldRadius = PLAYER_SIZE/2 + 2;
    ctx.strokeStyle = '#66f';
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.arc(0, 0, shieldRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  
  // Player body
  ctx.fillStyle = '#000';
  ctx.fillRect(-PLAYER_SIZE/2, -PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE);
  
  ctx.restore();
  
  // Level indicator
  const level = Math.floor(state.score / 20) + 1;
  if(level > 1){
    ctx.fillStyle = '#666';
    ctx.font = '12px monospace';
    ctx.fillText('Level ' + level, 10, H - 20);
  }
  
  ctx.restore();
}

function endGame(){
  state.gameOver = true;
  state.running = false;
  spawnParticles(state.player.x + PLAYER_SIZE/2, state.player.y + PLAYER_SIZE/2, '#ff4c4c', 30);
  sounds.death();
  
  overlay.innerHTML = '<div><div style="font-weight:800;font-size:28px">GAME OVER</div>' +
    '<div style="margin-top:12px;font-size:18px">Score: '+state.score+'</div>' +
    '<div style="margin-top:4px;font-size:16px">Best: '+state.best+'</div>' +
    '<div style="opacity:0.85;margin-top:16px;font-size:14px">Press R to restart</div></div>';
  overlay.classList.add('show');
}

let last = performance.now();
function loop(t){
  const dt = t - last;
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
