<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Bubble Pop — Pastel Arcade</title>
<style>
  :root{--bg:#fff;--fg:#000}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
  .wrap{height:100%;display:flex;align-items:center;justify-content:center}
  canvas{background:var(--bg);border:4px solid var(--fg);box-shadow:0 12px 30px rgba(0,0,0,0.08);display:block}
  #hud{position:fixed;right:18px;top:16px;font-weight:700;text-align:right;font-size:14px}
  #hint{position:fixed;right:18px;bottom:14px;font-size:13px;opacity:0.75;text-align:right}
  #center{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center}
  .btn{display:inline-block;margin-top:12px;padding:8px 12px;border:2px solid var(--fg);cursor:pointer}
  @media (max-width:600px){canvas{width:360px;height:600px}}
</style>
</head>
<body>
  <div id="hud">Score: <span id="score">0</span> &nbsp;|&nbsp; Lives: <span id="lives">3</span> &nbsp;|&nbsp; Best: <span id="best">0</span></div>
  <div id="hint">↑ ↓ ← → or WASD • Space to start • R restart</div>
  <div class="wrap">
    <canvas id="c" width="420" height="600" aria-label="Bubble Pop pastel arcade"></canvas>
  </div>
  <div id="center"></div>

<script>
// Bubble Pop — pastel arcade
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const bestEl = document.getElementById('best');
const center = document.getElementById('center');

// Pastel colors for bubbles
const pastelColors = ['#FFB6C1', '#E6E6FA', '#98FB98', '#F0E68C', '#FFA07A', '#87CEEB', '#DDA0DD', '#F5DEB3', '#90EE90', '#FFE4E1'];
// Bomb colors (darker, more ominous)
const bombColors = ['#8B0000', '#2F2F2F', '#4B0082'];

// Audio helper
const ac = new (window.AudioContext||window.webkitAudioContext)();
function sfx(f=440, t=0.08, type='square', vol=0.08, glide=0){
  const o = ac.createOscillator();
  const g = ac.createGain();
  o.type = type;
  o.frequency.setValueAtTime(f, ac.currentTime);
  if(glide) o.frequency.exponentialRampToValueAtTime(f*glide, ac.currentTime+t);
  g.gain.setValueAtTime(vol, ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+t);
  o.connect(g); g.connect(ac.destination);
  o.start(); o.stop(ac.currentTime + t);
}

let state = {
  player: { x: W/2, y: H-60, size: 18, speed: 5, vx: 0, vy: 0, trail: [] },
  bubbles: [],
  particles: [],
  score: 0,
  lives: 3,
  best: +localStorage.getItem('bubble_pop_best') || 0,
  running: false,
  gameOver: false,
  screenShake: 0,
  spawnTimer: 0,
  spawnDelay: 2000,
  difficulty: 1,
  gameTime: 0,
  shakeTimer: 0
};
bestEl.textContent = state.best;
livesEl.textContent = state.lives;

// input
const keys = {};
window.addEventListener('keydown', e=>{ 
  keys[e.key]=true; 
  if(e.key===' ' && !state.running && !state.gameOver) start(); 
  if(e.key==='r'||e.key==='R') reset();
});
window.addEventListener('keyup', e=> keys[e.key]=false);

function start(){ 
  state.running = true; 
  center.innerHTML='';
  spawnBubble();
}

function reset(){ 
  state.player.x = W/2;
  state.player.y = H-60;
  state.player.vx = 0;
  state.player.vy = 0;
  state.player.trail = [];
  state.bubbles = [];
  state.particles = [];
  state.score = 0; 
  state.lives = 3;
  state.running = false; 
  state.gameOver = false; 
  state.screenShake = 0;
  state.spawnTimer = 0;
  state.spawnDelay = 2000;
  state.difficulty = 1;
  state.gameTime = 0;
  scoreEl.textContent = '0';
  livesEl.textContent = '3'; 
  center.innerHTML = '<div style="font-weight:700;font-size:20px">Bubble Pop</div><div style="opacity:0.8;margin-top:8px">Pop bubbles by colliding into them!</div><div style="opacity:0.6;margin-top:6px">Press Space to start</div>'; 
}

function spawnBubble(){
  if(!state.running) return;
  const maxCount = 3 + Math.floor(state.difficulty * 1.5);
  const count = 2 + Math.random() * maxCount;
  for(let n = 0; n < count; n++){
    const size = 15 + Math.random() * 25;
    let x, y;
    if(Math.random() < 0.6) {
      x = size + Math.random() * (W - size * 2);
      y = -size;
    } else {
      if(Math.random() < 0.5) { x = -size; y = size + Math.random() * (H/2); }
      else { x = W + size; y = size + Math.random() * (H/2); }
    }
    const bombChance = Math.min(0.15 + state.difficulty * 0.015, 0.6);
    const isBomb = Math.random() < bombChance;
    const color = isBomb ? bombColors[Math.floor(Math.random() * bombColors.length)] : pastelColors[Math.floor(Math.random() * pastelColors.length)];
    const speed = 1 + Math.random() * 2 + (state.difficulty * 0.3);
    let vx = (Math.random() - 0.5) * 2;
    let vy = speed;
    if(x < 0) vx = Math.abs(vx) + 1;
    if(x > W) vx = -Math.abs(vx) - 1;
    state.bubbles.push({x,y,size,color,vx,vy,wobble:Math.random()*Math.PI*2,pulse:Math.random()*Math.PI*2,rotation:0,rotSpeed:(Math.random()-0.5)*0.05,trail:[],sparkles:[],isBomb});
  }
}

function spawnParticles(x, y, color, count=12){
  for(let i=0; i<count; i++){
    state.particles.push({
      x, y,
      vx: (Math.random()-0.5)*8,
      vy: (Math.random()-0.5)*8,
      life: 1,
      size: 2+Math.random()*4,
      color: color
    });
  }
}

function update(dt){
  if(state.shakeTimer > 0){
    state.shakeTimer -= dt;
    if(state.shakeTimer <= 0){ state.screenShake = 0; }
    else { state.screenShake = 12 * (state.shakeTimer / 500); }
  }
  if(state.gameOver){
    state.screenShake = Math.max(0, state.screenShake-0.8);
    state.particles.forEach(p=>{p.x+=p.vx; p.y+=p.vy; p.vy+=0.15; p.life-=0.015;});
    state.particles = state.particles.filter(p=>p.life>0);
    return;
  }
  if(!state.running) return;
  state.gameTime += dt;

  // movement
  let moving=false;
  if(keys['ArrowLeft']||keys['a']||keys['A']){state.player.vx=Math.max(state.player.vx-0.8,-state.player.speed);moving=true;}
  if(keys['ArrowRight']||keys['d']||keys['D']){state.player.vx=Math.min(state.player.vx+0.8,state.player.speed);moving=true;}
  if(keys['ArrowUp']||keys['w']||keys['W']){state.player.vy=Math.max(state.player.vy-0.8,-state.player.speed);moving=true;}
  if(keys['ArrowDown']||keys['s']||keys['S']){state.player.vy=Math.min(state.player.vy+0.8,state.player.speed);moving=true;}
  if(!moving){
    state.player.vx *= 0.6;
    state.player.vy *= 0.6;
    if(Math.abs(state.player.vx) < 0.2) state.player.vx = 0;
    if(Math.abs(state.player.vy) < 0.2) state.player.vy = 0;
  }
  state.player.x+=state.player.vx; state.player.y+=state.player.vy;
  state.player.x=Math.max(state.player.size,Math.min(W-state.player.size,state.player.x));
  state.player.y=Math.max(state.player.size,Math.min(H-state.player.size,state.player.y));

  // trails
  if(Math.abs(state.player.vx)>1||Math.abs(state.player.vy)>1){
    state.player.trail.push({x:state.player.x,y:state.player.y,life:1,size:state.player.size});
  }
  if(state.player.trail.length>8) state.player.trail.shift();
  state.player.trail.forEach(t=>t.life-=0.12);
  state.player.trail=state.player.trail.filter(t=>t.life>0);

  // spawn new
  state.spawnTimer+=dt;
  if(state.spawnTimer>=state.spawnDelay){
    state.spawnTimer=0; spawnBubble();
    const timeInSeconds=state.gameTime/1000;
    state.spawnDelay=Math.max(800,2000-(timeInSeconds*20));
    state.difficulty=Math.floor(timeInSeconds/15)+1;
  }

  // bubbles
  state.bubbles.forEach((bubble,index)=>{
    bubble.x+=bubble.vx; bubble.y+=bubble.vy;
    bubble.wobble+=0.08; bubble.pulse+=0.06; bubble.rotation+=bubble.rotSpeed;
    const dx=state.player.x-bubble.x; const dy=state.player.y-bubble.y; const dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<state.player.size+bubble.size-5){
      state.bubbles.splice(index,1);
      if(bubble.isBomb){
        spawnParticles(bubble.x,bubble.y,'#ff4444',25);
        spawnParticles(bubble.x,bubble.y,'#ffaa00',20);
        spawnParticles(bubble.x,bubble.y,'#ffff66',15);
        sfx(120,0.2,'square',0.3,4);
        sfx(80,0.25,'sawtooth',0.25,2);
        sfx(50,0.3,'triangle',0.2,0.5);
        state.shakeTimer=250;
        state.lives--; livesEl.textContent=state.lives;
        if(state.lives<=0){
          state.gameOver=true;
          center.innerHTML='<div style="font-weight:700;font-size:20px">Game Over</div><div style="opacity:0.8;margin-top:8px">Press R to restart</div>';
        }
      } else {
        state.score++; scoreEl.textContent=state.score;
        if(state.score>state.best){state.best=state.score; bestEl.textContent=state.best; localStorage.setItem('bubble_pop_best',state.best); sfx(2000,0.12,'square',0.15); sfx(1500,0.1,'triangle',0.12);}
        sfx(500,0.08,'square',0.12,1.2); sfx(750,0.05,'triangle',0.08,0.9);
        spawnParticles(bubble.x,bubble.y,bubble.color,15);
      }
    }
  });

  // particles
  state.particles.forEach(p=>{p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life-=0.018; p.vx*=0.99;});
  state.particles=state.particles.filter(p=>p.life>0);
}

function draw(){
  ctx.save();
  if(state.screenShake>0){ctx.translate((Math.random()-0.5)*state.screenShake,(Math.random()-0.5)*state.screenShake);}
  ctx.clearRect(0,0,W,H);
  state.particles.forEach(p=>{ctx.globalAlpha=Math.max(0,p.life*0.8);ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,p.size*p.life,0,Math.PI*2);ctx.fill();}); ctx.globalAlpha=1;
  state.bubbles.forEach(bubble=>{
    bubble.trail.forEach(t=>{ctx.globalAlpha=t.life*0.3;ctx.fillStyle=bubble.color;ctx.beginPath();ctx.arc(t.x,t.y,t.size*t.life*0.8,0,Math.PI*2);ctx.fill();});
    ctx.globalAlpha=1; ctx.save(); ctx.translate(bubble.x+Math.sin(bubble.wobble)*2,bubble.y); ctx.rotate(bubble.rotation);
    const pulseScale=1+Math.sin(bubble.pulse)*0.05; ctx.scale(pulseScale,pulseScale);
    if(bubble.isBomb){
      ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(0,0,bubble.size,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#ff2222'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,bubble.size,0,Math.PI*2); ctx.stroke();
      ctx.strokeStyle='#aaa'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,-bubble.size); ctx.lineTo(0,-bubble.size-10); ctx.stroke();
      if(Math.random()<0.5){ctx.fillStyle='#ffcc00'; ctx.beginPath(); ctx.arc(0,-bubble.size-12,3,0,Math.PI*2); ctx.fill();}
    } else {
      const gradient=ctx.createRadialGradient(0,-bubble.size/3,0,0,0,bubble.size);
      gradient.addColorStop(0,'rgba(255,255,255,0.8)'); gradient.addColorStop(0.7,bubble.color); gradient.addColorStop(1,bubble.color);
      ctx.fillStyle=gradient; ctx.beginPath(); ctx.arc(0,0,bubble.size,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,bubble.size,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  });
  state.player.trail.forEach(t=>{ctx.globalAlpha=t.life*0.5;ctx.fillStyle='#333';ctx.beginPath();ctx.arc(t.x,t.y,t.size*t.life,0,Math.PI*2);ctx.fill();});
  ctx.globalAlpha=1; ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(state.player.x,state.player.y,state.player.size,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(state.player.x,state.player.y,state.player.size,0,Math.PI*2); ctx.stroke();
  if(state.running&&state.difficulty>1){ctx.fillStyle='#666'; ctx.font='12px system-ui'; ctx.textAlign='right'; ctx.fillText('Level '+state.difficulty,W-20,H-20);}
  ctx.restore();
}

let last=performance.now();
function loop(t){const dt=t-last; last=t; update(dt); draw(); requestAnimationFrame(loop);}
center.innerHTML='<div style="font-weight:700;font-size:20px">Bubble Pop</div><div style="opacity:0.8;margin-top:8px">Pop bubbles by colliding into them!</div><div style="opacity:0.6;margin-top:6px">Press Space to start</div>';
reset(); requestAnimationFrame(loop);
</script>
</body>
</html>
