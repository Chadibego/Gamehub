<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dodge the Blocks</title>
<style>
  body {
    margin: 0;
    background: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    color: #333;
    font-family: sans-serif;
    overflow: hidden;
  }

  canvas {
    background: #fff;
    border: 2px solid #ddd;
    display: block;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  }

  #score {
    position: absolute;
    top: 10px;
    font-size: 24px;
    color: #000;
  }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="400" height="600"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const player = { 
    x: 180, 
    y: 550, 
    width: 40, 
    height: 40, 
    speed: 5, 
    scale: 1, 
    targetScale: 1,
    rotation: 0,
    targetRotation: 0,
    bob: 0,
    trail: [],
    velocity: { x: 0, y: 0 },
    afterImages: [],
    squash: 1,
    stretch: 1,
    glow: 0
  };
  const blocks = [];
  let score = 0;
  let gameOver = false;
  let gameOverAnimation = 0;
  let screenShake = 0;
  let speedIncreaseShake = 0;
  let speedIncreaseShakeTimer = 0;
  let lastSpeedIncrease = 0;
  let particles = [];
  let backgroundWaves = [];

  // Sound effects using Web Audio API
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  
  // Soft, subtle color palette
  const softColors = [
    '#E8B4CB', // Soft pink
    '#B4D4E8', // Soft blue
    '#D4E8B4', // Soft green
    '#E8D4B4', // Soft peach
    '#C4B4E8', // Soft purple
    '#B4E8D4', // Soft mint
    '#E8C4B4', // Soft coral
    '#D4B4E8'  // Soft lavender
  ];
  
  function playSound(frequency, duration, type = 'sine') {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    oscillator.type = type;
    
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
  }

  function resetGame() {
    blocks.length = 0;
    particles.length = 0;
    backgroundWaves.length = 0;
    score = 0;
    gameOver = false;
    gameOverAnimation = 0;
    screenShake = 0;
    speedIncreaseShake = 0;
    speedIncreaseShakeTimer = 0;
    lastSpeedIncrease = 0;
    player.x = 180;
    player.y = 550;
    player.scale = 1;
    player.targetScale = 1;
    player.rotation = 0;
    player.targetRotation = 0;
    player.bob = 0;
    player.trail = [];
    player.velocity = { x: 0, y: 0 };
    player.afterImages = [];
    player.squash = 1;
    player.stretch = 1;
    player.glow = 0;
    document.getElementById('score').textContent = 'Score: 0';
    playSound(440, 0.1); // Reset sound
  }

  // Controls
  const keys = {};
  document.addEventListener('keydown', e => {
    keys[e.key] = true;
    if (e.key === 'r' || e.key === 'R') {
      if (gameOver) {
        resetGame();
      }
    }
  });
  document.addEventListener('keyup', e => keys[e.key] = false);

  function spawnBlock() {
    const size = Math.random() * 30 + 20;
    const x = Math.random() * (canvas.width - size);
    // Calculate speed multiplier based on score (every 30 points = +1 speed)
    const speedMultiplier = 1 + Math.floor(score / 30) * 0.5;
    blocks.push({ 
      x, 
      y: -size, 
      width: size, 
      height: size, 
      speed: (Math.random() * 3 + 2) * speedMultiplier,
      rotation: 0,
      rotationSpeed: (Math.random() - 0.5) * 0.1,
      color: softColors[Math.floor(Math.random() * softColors.length)],
      scale: 0,
      targetScale: 1,
      wobble: 0,
      pulse: Math.random() * Math.PI * 2,
      sparkles: []
    });
    
    // Create spawn particles
    for (let i = 0; i < 8; i++) {
      particles.push({
        x: x + size/2,
        y: -size/2,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 1,
        maxLife: 1,
        size: Math.random() * 3 + 1,
        color: softColors[Math.floor(Math.random() * softColors.length)]
      });
    }
    
    playSound(200, 0.05, 'square'); // Block spawn sound
  }

  function update() {
    if (gameOver) {
      gameOverAnimation += 0.05;
      if (screenShake > 0) screenShake -= 0.5;
      
      // Update speed increase shake even during game over
      if (speedIncreaseShakeTimer > 0) {
        speedIncreaseShakeTimer--;
        // Fade out over 3 seconds (180 frames at 60fps)
        const fadeProgress = speedIncreaseShakeTimer / 180;
        speedIncreaseShake = 15 * fadeProgress * fadeProgress; // Quadratic fade
      }
      
      // Update particles even when game over
      particles.forEach(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= 0.02;
        particle.vy += 0.1; // gravity
      });
      particles = particles.filter(p => p.life > 0);
      
      return;
    }

    // Update speed increase shake effect
    if (speedIncreaseShakeTimer > 0) {
      speedIncreaseShakeTimer--;
      // Fade out over 3 seconds (180 frames at 60fps)
      const fadeProgress = speedIncreaseShakeTimer / 180;
      speedIncreaseShake = 15 * fadeProgress * fadeProgress; // Quadratic fade for smooth transition
    }

    // Check for speed increase milestone
    const currentSpeedLevel = Math.floor(score / 30);
    if (currentSpeedLevel > lastSpeedIncrease) {
      lastSpeedIncrease = currentSpeedLevel;
      // Play special sound and start 3-second shake effect
      playSound(1000, 0.2);
      speedIncreaseShake = 15; // Strong initial shake
      speedIncreaseShakeTimer = 180; // 3 seconds at 60fps
      player.glow = 1;
      
      // Create celebration particles
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: player.x + player.width/2,
          y: player.y + player.height/2,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 1,
          maxLife: 1,
          size: Math.random() * 4 + 2,
          color: '#FFD700'
        });
      }
    }

    // Player idle bobbing animation
    player.bob += 0.15;
    player.glow = Math.max(0, player.glow - 0.05);
    
    // Smooth player scaling, rotation, and squash/stretch animations
    player.scale += (player.targetScale - player.scale) * 0.25;
    player.rotation += (player.targetRotation - player.rotation) * 0.2;
    player.squash += (1 - player.squash) * 0.3;
    player.stretch += (1 - player.stretch) * 0.3;

    // Update player velocity for physics
    player.velocity.x *= 0.85; // friction
    player.velocity.y *= 0.85;

    // Create after images for fast movement
    if (Math.abs(player.velocity.x) > 2) {
      player.afterImages.push({
        x: player.x,
        y: player.y,
        life: 0.6,
        rotation: player.rotation,
        scale: player.scale
      });
    }
    if (player.afterImages.length > 5) player.afterImages.shift();
    player.afterImages.forEach(img => img.life -= 0.1);
    player.afterImages = player.afterImages.filter(img => img.life > 0);

    // Update trail with more dynamic effects
    player.trail.push({ 
      x: player.x + player.width/2, 
      y: player.y + player.height/2, 
      life: 1,
      size: 8 + Math.abs(player.velocity.x),
      rotation: player.rotation 
    });
    if (player.trail.length > 12) player.trail.shift();
    player.trail.forEach(point => point.life -= 0.08);

    // Move player with enhanced physics and animations
    let isMoving = false;
    const prevX = player.x;
    
    if ((keys['ArrowLeft'] || keys['a'] || keys['A']) && player.x > 0) {
      player.x -= player.speed;
      player.velocity.x = -player.speed;
      player.targetScale = 0.7;
      player.targetRotation = -0.2;
      player.squash = 0.8; // squash horizontally
      player.stretch = 1.2; // stretch vertically
      isMoving = true;
    } else if ((keys['ArrowRight'] || keys['d'] || keys['D']) && player.x + player.width < canvas.width) {
      player.x += player.speed;
      player.velocity.x = player.speed;
      player.targetScale = 0.7;
      player.targetRotation = 0.2;
      player.squash = 0.8; // squash horizontally  
      player.stretch = 1.2; // stretch vertically
      isMoving = true;
    } else {
      player.targetScale = 1;
      player.targetRotation = 0;
      player.velocity.x = 0;
    }

    // Create movement particles
    if (isMoving && Math.random() < 0.3) {
      particles.push({
        x: player.x + player.width/2 + (Math.random() - 0.5) * 20,
        y: player.y + player.height,
        vx: (Math.random() - 0.5) * 2,
        vy: Math.random() * 2 + 1,
        life: 1,
        maxLife: 1,
        size: Math.random() * 2 + 1,
        color: '#666'
      });
    }

    // Update blocks with more animations
    blocks.forEach(block => {
      block.y += block.speed;
      block.rotation += block.rotationSpeed;
      block.scale += (block.targetScale - block.scale) * 0.1;
      block.wobble += 0.05;
      block.pulse += 0.1;
      
      // Add sparkles to blocks occasionally
      if (Math.random() < 0.02) {
        block.sparkles.push({
          x: Math.random() * block.width,
          y: Math.random() * block.height,
          life: 1,
          size: Math.random() * 2 + 1
        });
      }
      
      // Update sparkles
      block.sparkles.forEach(sparkle => sparkle.life -= 0.05);
      block.sparkles = block.sparkles.filter(s => s.life > 0);
    });

    // Update particles
    particles.forEach(particle => {
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.life -= 0.015;
      particle.vy += 0.05; // subtle gravity
      particle.vx *= 0.99; // air resistance
    });
    particles = particles.filter(p => p.life > 0);

    // Check collisions with enhanced effects
    blocks.forEach((block, blockIndex) => {
      if (
        player.x < block.x + block.width &&
        player.x + player.width > block.x &&
        player.y < block.y + block.height &&
        player.y + player.height > block.y
      ) {
        gameOver = true;
        screenShake = 20;
        
        // Explosion particles on collision
        for (let i = 0; i < 30; i++) {
          particles.push({
            x: player.x + player.width/2,
            y: player.y + player.height/2,
            vx: (Math.random() - 0.5) * 12,
            vy: (Math.random() - 0.5) * 12,
            life: 1,
            maxLife: 1,
            size: Math.random() * 5 + 2,
            color: block.color
          });
        }
        
        playSound(150, 0.3, 'sawtooth');
      }
    });

    // Remove off-screen blocks with enhanced effects
    for (let i = blocks.length - 1; i >= 0; i--) {
      if (blocks[i].y > canvas.height) {
        const block = blocks[i];
        blocks.splice(i, 1);
        score++;
        document.getElementById('score').textContent = 'Score: ' + score;
        playSound(800, 0.1);
        
        // Score celebration
        player.targetScale = 1.3;
        player.glow = 0.5;
        
        // Score particles
        for (let j = 0; j < 5; j++) {
          particles.push({
            x: block.x + block.width/2,
            y: canvas.height,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 3 - 2,
            life: 1,
            maxLife: 1,
            size: Math.random() * 3 + 1,
            color: block.color
          });
        }
        
        setTimeout(() => player.targetScale = 1, 150);
      }
    }
  }

  function draw() {
    ctx.save();
    
    // Screen shake effect
    if (screenShake > 0) {
      ctx.translate(
        (Math.random() - 0.5) * screenShake,
        (Math.random() - 0.5) * screenShake
      );
    }
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw particles first (behind everything)
    particles.forEach(particle => {
      ctx.save();
      ctx.globalAlpha = particle.life;
      ctx.fillStyle = particle.color;
      const size = particle.size * particle.life;
      ctx.fillRect(particle.x - size/2, particle.y - size/2, size, size);
      ctx.restore();
    });

    // Draw player after images for motion blur effect
    player.afterImages.forEach(img => {
      ctx.save();
      ctx.globalAlpha = img.life * 0.3;
      ctx.translate(img.x + player.width/2, img.y + player.height/2);
      ctx.rotate(img.rotation);
      ctx.scale(img.scale * player.squash, img.scale * player.stretch);
      ctx.fillStyle = '#000';
      ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
      ctx.restore();
    });

    // Draw enhanced player trail
    player.trail.forEach((point, index) => {
      if (point.life > 0) {
        ctx.save();
        ctx.globalAlpha = point.life * 0.4;
        ctx.translate(point.x, point.y);
        ctx.rotate(point.rotation);
        ctx.fillStyle = '#333';
        const size = point.size * point.life;
        ctx.fillRect(-size/2, -size/2, size, size);
        ctx.restore();
      }
    });

    // Draw player with all animations and glow
    ctx.save();
    const playerCenterX = player.x + player.width/2;
    const playerCenterY = player.y + player.height/2;
    
    // Add subtle idle bobbing
    const bobOffset = Math.sin(player.bob) * 3;
    
    ctx.translate(playerCenterX, playerCenterY + bobOffset);
    ctx.rotate(player.rotation);
    ctx.scale(player.scale * player.squash, player.scale * player.stretch);
    
    // Glow effect
    if (player.glow > 0) {
      ctx.save();
      ctx.globalAlpha = player.glow * 0.5;
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(-player.width/2 - 4, -player.height/2 - 4, player.width + 8, player.height + 8);
      ctx.restore();
    }
    
    // Draw player (completely black square)
    ctx.fillStyle = '#000';
    ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
    
    ctx.restore();

    // Draw blocks with enhanced animations
    blocks.forEach(block => {
      ctx.save();
      const blockCenterX = block.x + block.width/2;
      const blockCenterY = block.y + block.height/2;
      
      // Wobble and pulse effects
      const wobbleX = Math.sin(block.wobble * 3) * 1;
      const wobbleY = Math.cos(block.wobble * 2) * 0.5;
      const pulseScale = 1 + Math.sin(block.pulse) * 0.05;
      
      ctx.translate(blockCenterX + wobbleX, blockCenterY + wobbleY);
      ctx.rotate(block.rotation);
      ctx.scale(block.scale * pulseScale, block.scale * pulseScale);
      
      // Draw block with soft color
      ctx.fillStyle = block.color;
      ctx.fillRect(-block.width/2, -block.height/2, block.width, block.height);
      
      // Draw sparkles on blocks
      block.sparkles.forEach(sparkle => {
        ctx.save();
        ctx.globalAlpha = sparkle.life;
        ctx.fillStyle = '#FFF';
        const sparkleSize = sparkle.size * sparkle.life;
        ctx.fillRect(
          sparkle.x - block.width/2 - sparkleSize/2, 
          sparkle.y - block.height/2 - sparkleSize/2, 
          sparkleSize, 
          sparkleSize
        );
        ctx.restore();
      });
      
      // Subtle border
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.strokeRect(-block.width/2, -block.height/2, block.width, block.height);
      ctx.restore();
    });

    // Draw difficulty indicator (black text)
    const speedLevel = Math.floor(score / 30);
    if (speedLevel > 0) {
      ctx.fillStyle = '#000';
      ctx.font = '14px sans-serif';
      ctx.fillText(`Speed Level: ${speedLevel}`, 10, canvas.height - 20);
    }

    if (gameOver) {
      // Pulsing game over text (black)
      const pulse = Math.sin(gameOverAnimation * 4) * 0.1 + 1;
      ctx.save();
      ctx.translate(canvas.width/2, canvas.height/2);
      ctx.scale(pulse, pulse);
      
      ctx.fillStyle = '#000';
      ctx.font = '36px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', 0, -25);
      ctx.font = '18px sans-serif';
      ctx.fillText('Press R to restart', 0, 25);
      ctx.restore();
    }
    
    ctx.restore();
  }

  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  gameLoop();

  // Dynamic spawn scheduling with 50% base faster spawn
  // and extra 10% faster from Level 2 (>=15 points)
  let spawnDelay = 500;
  function scheduleSpawn() {
    if (!gameOver) spawnBlock();
    let level = Math.floor(score / 15);
    let baseDelay = 500 - level * 50;
    if (level >= 1) baseDelay *= 0.9; // 10% faster at level 2+
    spawnDelay = Math.max(200, baseDelay);
    setTimeout(scheduleSpawn, spawnDelay);
  }
  scheduleSpawn();

  // Modify spawnBlock speed scaling every 15 points
  const _originalSpawnBlock = spawnBlock;
  spawnBlock = function(){
    const size = Math.random() * 30 + 20;
    const x = Math.random() * (canvas.width - size);
    const speedMultiplier = 1 + Math.floor(score / 15) * 0.5;
    blocks.push({
      x, y: -size, width: size, height: size,
      speed: (Math.random() * 3 + 2) * speedMultiplier,
      rotation: 0,
      rotationSpeed: (Math.random() - 0.5) * 0.1,
      color: softColors[Math.floor(Math.random() * softColors.length)],
      scale: 0,
      targetScale: 1,
      wobble: 0,
      pulse: Math.random() * Math.PI * 2,
      sparkles: []
    });
    for (let i = 0; i < 8; i++) {
      particles.push({
        x: x + size/2,
        y: -size/2,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 1,
        maxLife: 1,
        size: Math.random() * 3 + 1,
        color: softColors[Math.floor(Math.random() * softColors.length)]
      });
    }
    playSound(200, 0.05, 'square');
  };

</script>
</body>
</html>