<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cube Jump â€“ Arcade</title>
<style>
  :root{--bg:#fff;--fg:#000}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,Menlo,Consolas,monospace}
  .wrap{height:100%;display:flex;align-items:center;justify-content:center}
  canvas{background:var(--bg);border:4px solid var(--fg);box-shadow:0 12px 30px rgba(0,0,0,0.08);display:block}
  #hud{position:fixed;left:18px;top:16px;font-weight:400}
  #hint{position:fixed;right:18px;top:14px;font-size:13px;opacity:0.75}
  .overlay{
    position:fixed;inset:0;display:grid;place-items:center;text-align:center;
    font-size:24px;color:var(--fg);pointer-events:none;z-index:3;
    opacity:0;transform:scale(0.95);transition:opacity .3s ease,transform .3s ease;
    background:rgba(255,255,255,0.95);
    backdrop-filter:blur(4px);
  }
  .overlay.show{opacity:1;transform:scale(1);}
  .overlay>div{animation:slideUp 0.5s ease;}
  @keyframes slideUp{from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}
  @media (max-width:600px){canvas{width:360px;height:600px}}
</style>
</head>
<body>
  <div id="hud">Score: <span id="score">0</span> &nbsp;|&nbsp; Best: <span id="best">0</span></div>
  <div id="hint">Space or Click to jump â€¢ R or Space restart</div>
  <div class="wrap">
    <canvas id="c" width="420" height="600" aria-label="Cube Jump arcade"></canvas>
  </div>
  <div class="overlay show" id="overlay">
    <div>
      <div style="font-weight:700;font-size:26px">Cube Jump</div>
      <div style="opacity:0.8;margin-top:10px;font-size:16px">Tap to jump through the pipes</div>
      <div style="opacity:0.7;margin-top:12px;font-size:14px">Press Space to start</div>
    </div>
  </div>

<script>
// Cube Jump â€“ arcade
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const overlay = document.getElementById('overlay');

// Colors - black and white style
const playerColor = '#000';
const pipeColor = '#000';

// Audio helper
const ac = new (window.AudioContext||window.webkitAudioContext)();
function sfx(f=440, t=0.08, type='square', vol=0.08, glide=0){
  const o = ac.createOscillator();
  const g = ac.createGain();
  o.type = type;
  o.frequency.setValueAtTime(f, ac.currentTime);
  if(glide) o.frequency.exponentialRampToValueAtTime(f*glide, ac.currentTime+t);
  g.gain.setValueAtTime(vol, ac.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+t);
  o.connect(g); g.connect(ac.destination);
  o.start(); o.stop(ac.currentTime + t);
}

const GROUND_Y = H - 60;
const GRAVITY = 0.5;
const FLAP = -9;
const PIPE_W = 60;
const PIPE_GAP = 140;
const PIPE_SPEED = 2.5;

let state = {
  bird: { x: 80, y: H/2, vy: 0, r: 15, rotation: 0, trail: [] },
  pipes: [],
  clouds: [],
  particles: [],
  score: 0,
  best: +localStorage.getItem('cubejump_best') || 0,
  running: false,
  gameOver: false,
  firstStart: true,
  screenShake: 0
};
bestEl.textContent = state.best;

// Init clouds
for(let i=0; i<3; i++){
  state.clouds.push({
    x: Math.random() * W,
    y: Math.random() * 150 + 30,
    w: 60 + Math.random() * 40,
    speed: 0.3 + Math.random() * 0.3
  });
}

// input
const keys = {};
window.addEventListener('keydown', e=>{ 
  keys[e.key]=true;
  if(e.code==='Space'){
    if(state.firstStart && !state.running){
      start();
    } else if(state.gameOver){
      reset();
    } else {
      jump();
    }
  }
  if(e.key==='r'||e.key==='R'){
    if(state.gameOver) reset();
  }
});
window.addEventListener('keyup', e=> keys[e.key]=false);
canvas.addEventListener('click', ()=>{
  if(state.firstStart && !state.running){
    start();
  } else if(state.gameOver){
    reset();
  } else {
    jump();
  }
});

function start(){ 
  state.running = true; 
  state.firstStart = false;
  overlay.classList.remove('show');
  spawnPipe();
}

function reset(){ 
  state.bird.y = H/2;
  state.bird.vy = 0;
  state.bird.rotation = 0;
  state.bird.trail = [];
  state.pipes = [];
  state.particles = [];
  state.score = 0; 
  state.running = false; 
  state.gameOver = false; 
  state.screenShake = 0;
  scoreEl.textContent = '0';
  start();
}

function jump(){
  if(!state.running || state.gameOver) return;
  state.bird.vy = FLAP;
  state.bird.rotation = -25;
  sfx(800, 0.1, 'square', 0.08);
  
  // Jump particles
  for(let i=0; i<5; i++){
    state.particles.push({
      x: state.bird.x - 10,
      y: state.bird.y,
      vx: -Math.random()*2-1,
      vy: (Math.random()-0.5)*4,
      life: 1,
      size: 2+Math.random()*3,
      color: '#000'
    });
  }
}

function spawnPipe(){
  const minY = 100;
  const maxY = GROUND_Y - PIPE_GAP - 100;
  const topH = minY + Math.random() * (maxY - minY);
  
  state.pipes.push({
    x: W,
    topH: topH,
    botY: topH + PIPE_GAP,
    scored: false
  });
}

function spawnParticles(x, y, color, count=15){
  for(let i=0; i<count; i++){
    state.particles.push({
      x, y,
      vx: (Math.random()-0.5)*8,
      vy: (Math.random()-0.5)*8,
      life: 1,
      size: 2+Math.random()*4,
      color: color
    });
  }
}

function update(dt){
  if(state.gameOver){
    state.screenShake = Math.max(0, state.screenShake-0.8);
    state.particles.forEach(p=>{
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.15;
      p.life -= 0.015;
    });
    state.particles = state.particles.filter(p=>p.life>0);
    return;
  }

  if(!state.running) return;

  const b = state.bird;
  b.vy += GRAVITY;
  b.y += b.vy;
  b.rotation = Math.min(Math.max(b.vy * 3, -25), 90);
  
  b.trail.push({x: b.x, y: b.y, life: 1});
  if(b.trail.length > 8) b.trail.shift();
  b.trail.forEach(t => t.life -= 0.12);
  b.trail = b.trail.filter(t => t.life > 0);

  if(b.y + b.r >= GROUND_Y){
    b.y = GROUND_Y - b.r;
    endGame();
    return;
  }

  if(b.y - b.r <= 0){
    b.y = b.r;
    b.vy = 0;
  }

  state.pipes.forEach((pipe, idx) => {
    pipe.x -= PIPE_SPEED;

    if(!pipe.scored && b.x > pipe.x + PIPE_W){
      pipe.scored = true;
      state.score++;
      scoreEl.textContent = state.score;
      sfx(1200, 0.15, 'triangle', 0.1);
      
      if(state.score > state.best){
        state.best = state.score;
        bestEl.textContent = state.best;
        localStorage.setItem('cubejump_best', state.best);
        sfx(1800, 0.15, 'triangle', 0.12);
      }
    }

    const playerLeft = b.x - b.r;
    const playerRight = b.x + b.r;
    const playerTop = b.y - b.r;
    const playerBottom = b.y + b.r;
    
    const pipeLeft = pipe.x;
    const pipeRight = pipe.x + PIPE_W;
    
    if(playerRight > pipeLeft && playerLeft < pipeRight){
      if(playerTop < pipe.topH || playerBottom > pipe.botY){
        endGame();
      }
    }

    if(pipe.x + PIPE_W < 0){
      state.pipes.splice(idx, 1);
    }
  });

  if(state.pipes.length === 0 || state.pipes[state.pipes.length-1].x < W - 200){
    spawnPipe();
  }

  state.clouds.forEach(cloud => {
    cloud.x -= cloud.speed;
    if(cloud.x + cloud.w < 0){
      cloud.x = W;
      cloud.y = Math.random() * 150 + 30;
    }
  });

  state.particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life -= 0.018;
    p.vx *= 0.99;
  });
  state.particles = state.particles.filter(p => p.life > 0);
}

function endGame(){
  state.gameOver = true;
  state.running = false;
  state.screenShake = 18;
  spawnParticles(state.bird.x, state.bird.y, '#000', 30);
  sfx(160, 0.4, 'sawtooth', 0.09, 2);
  
  let medal = '';
  if(state.score >= 40) medal = 'ðŸ¥‡';
  else if(state.score >= 20) medal = 'ðŸ¥ˆ';
  else if(state.score >= 10) medal = 'ðŸ¥‰';
  
  overlay.innerHTML = '<div><div style="font-weight:800;font-size:28px">GAME OVER</div>' +
    (medal ? '<div style="font-size:48px;margin-top:8px">'+medal+'</div>' : '') +
    '<div style="margin-top:12px;font-size:18px">Score: '+state.score+'</div>' +
    '<div style="margin-top:4px;font-size:16px">Best: '+state.best+'</div>' +
    '<div style="opacity:0.85;margin-top:16px;font-size:14px">Press R or Space to restart</div></div>';
  overlay.classList.add('show');
}

function draw(){
  ctx.save();
  
  if(state.screenShake > 0){
    const s = state.screenShake;
    ctx.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
  }
  
  ctx.clearRect(0, 0, W, H);

  state.particles.forEach(p => {
    ctx.globalAlpha = Math.max(0, p.life * 0.8);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;

  ctx.fillStyle = '#000';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  
  state.pipes.forEach(pipe => {
    ctx.fillRect(pipe.x, 0, PIPE_W, pipe.topH);
    ctx.fillRect(pipe.x, pipe.botY, PIPE_W, GROUND_Y-pipe.botY);
  });

  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(W, GROUND_Y);
  ctx.stroke();

  const b = state.bird;
  b.trail.forEach(t => {
    ctx.globalAlpha = t.life * 0.3;
    ctx.fillStyle = '#000';
    const size = b.r * 2 * t.life;
    ctx.fillRect(t.x - size/2, t.y - size/2, size, size);
  });
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.rotate(b.rotation * Math.PI / 180);
  ctx.fillStyle = '#000';
  ctx.fillRect(-b.r, -b.r, b.r*2, b.r*2);
  ctx.restore();
  ctx.restore();
}

let last = performance.now();
function loop(t){
  const dt = t - last;
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
